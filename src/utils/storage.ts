/**
 * IndexedDB utility for storing conversations data
 * Redesigned for scalability with 4000+ conversations
 */

const DB_NAME = "ChatLogsViewerDB";
const DB_VERSION = 5; // Added query result filters
const CONVERSATIONS_STORE = "conversations";
const FILE_META_STORE = "fileMeta";

export interface SparqlBlock {
  endpoint: string;
  query: string;
  results?: any[];
  bgp_count?: number;
}

export interface Message {
  content: string;
  role: "user" | "assistant";
  query_results?: {
    question?: string;
    sparql_query?: string;
    sparql_endpoint?: string;
    results?: any[];
    error?: string | null;
  };
}

export interface Step {
  node_id: string;
  label: string;
  details: string;
  substeps?: {label: string; details: string}[];
}

export interface Conversation {
  id?: number; // Auto-generated by IndexedDB
  timestamp: string;
  label: string; // "likes" | "dislikes" | "langfuse"
  messages: Message[];
  sparql_block?: SparqlBlock;
  steps: Step[];
  totalCost?: number;
  promptTokens?: number;
  completionTokens?: number;
  totalTokens?: number;
  // Indexed fields for fast filtering
  hasSparql: boolean;
  hasInvalidQuery: boolean;
  messageCount: number;
  bgpCount: number;
  // Searchable text (lowercase concatenation of messages and sparql for search)
  searchText: string;
  // Query result filters
  hasMultipleResults: boolean;
  hasZeroResults: boolean;
  hasErrors: boolean;
}

export interface FileMeta {
  id: string; // "likes" | "dislikes" | "langfuse"
  fileName: string;
  fileSize: number;
  uploadedAt: number;
  conversationCount: number;
}

export interface ConversationFilters {
  label: string;
  withSparql: boolean;
  withoutSparql: boolean;
  withInvalidQuery: boolean;
  minMessages: number;
  minBgps: number;
  searchQuery: string;
  withMultipleResults: boolean;
  withZeroResults: boolean;
  withErrors: boolean;
}

export interface PaginatedResult {
  conversations: Conversation[];
  total: number;
  page: number;
  pageSize: number;
  totalPages: number;
}

export interface Summary {
  likes: number;
  likes_sparql: number;
  dislikes: number;
  dislikes_sparql: number;
  langfuse: number;
  langfuse_sparql: number;
  sparql_total: number;
  conversation_total: number;
}

let dbInstance: IDBDatabase | null = null;

/**
 * Initialize IndexedDB with new schema
 */
const initDB = (): Promise<IDBDatabase> => {
  if (dbInstance) return Promise.resolve(dbInstance);

  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, DB_VERSION);

    request.onerror = () => {
      reject(new Error("Failed to open IndexedDB"));
    };

    request.onsuccess = () => {
      dbInstance = request.result;
      resolve(dbInstance);
    };

    request.onupgradeneeded = event => {
      const db = (event.target as IDBOpenDBRequest).result;

      // Clean up old stores
      const oldStores = ["uploadedFiles", "conversations"];
      for (const storeName of oldStores) {
        if (db.objectStoreNames.contains(storeName)) {
          db.deleteObjectStore(storeName);
        }
      }

      // Create file metadata store
      if (!db.objectStoreNames.contains(FILE_META_STORE)) {
        db.createObjectStore(FILE_META_STORE, {keyPath: "id"});
      }

      // Create conversations store with indexes for filtering
      const convStore = db.createObjectStore(CONVERSATIONS_STORE, {
        keyPath: "id",
        autoIncrement: true,
      });

      // Indexes for filtering
      convStore.createIndex("label", "label", {unique: false});
      convStore.createIndex("hasSparql", "hasSparql", {unique: false});
      convStore.createIndex("hasInvalidQuery", "hasInvalidQuery", {unique: false});
      convStore.createIndex("messageCount", "messageCount", {unique: false});
      convStore.createIndex("bgpCount", "bgpCount", {unique: false});
      // Compound index for common filter combinations
      convStore.createIndex("label_hasSparql", ["label", "hasSparql"], {unique: false});
      convStore.createIndex("label_timestamp", ["label", "timestamp"], {unique: false});
    };
  });
};

/**
 * Build searchable text from conversation for full-text search
 */
const buildSearchText = (conversation: Omit<Conversation, "id" | "hasSparql" | "hasInvalidQuery" | "messageCount" | "bgpCount" | "searchText" | "hasMultipleResults" | "hasZeroResults" | "hasErrors">): string => {
  const parts: string[] = [];
  for (const msg of conversation.messages) {
    parts.push(msg.content.toLowerCase());
  }
  if (conversation.sparql_block?.query) {
    parts.push(conversation.sparql_block.query.toLowerCase());
  }
  return parts.join(" ");
};

/**
 * Check if conversation has invalid query step
 */
const hasInvalidQueryStep = (steps: Step[]): boolean => {
  return steps.some(step => step.label.toLowerCase().includes("generated query invalid"));
};

/**
 * Check if conversation has queries with multiple results
 */
const hasMultipleResults = (messages: Message[]): boolean => {
  return messages.some(msg => msg.query_results && (msg.query_results.results?.length || 0) > 1);
};

/**
 * Check if conversation has queries with zero results
 */
const hasZeroResults = (messages: Message[]): boolean => {
  return messages.some(msg => msg.query_results && !msg.query_results.error && (msg.query_results.results?.length || 0) === 0);
};

/**
 * Check if conversation has queries with errors
 */
const hasErrors = (messages: Message[]): boolean => {
  return messages.some(msg => msg.query_results && msg.query_results.error);
};

/**
 * Store conversations from a file (replaces all conversations for that label)
 */
export const storeConversations = async (
  fileType: "likes" | "dislikes" | "langfuse",
  file: File,
  conversations: Omit<Conversation, "id" | "hasSparql" | "hasInvalidQuery" | "messageCount" | "bgpCount" | "searchText" | "hasMultipleResults" | "hasZeroResults" | "hasErrors">[]
): Promise<void> => {
  const db = await initDB();
  // First, delete all existing conversations for this file type
  await deleteConversationsByLabel(fileType);

  // Store file metadata
  const fileMeta: FileMeta = {
    id: fileType,
    fileName: file.name,
    fileSize: file.size,
    uploadedAt: Date.now(),
    conversationCount: conversations.length,
  };
  await new Promise<void>((resolve, reject) => {
    const transaction = db.transaction([FILE_META_STORE], "readwrite");
    const store = transaction.objectStore(FILE_META_STORE);
    const request = store.put(fileMeta);
    request.onsuccess = () => resolve();
    request.onerror = () => reject(new Error(`Failed to store file meta: ${file.name}`));
  });

  // Store conversations in batches for better performance
  const BATCH_SIZE = 100;
  for (let i = 0; i < conversations.length; i += BATCH_SIZE) {
    const batch = conversations.slice(i, i + BATCH_SIZE);
    await new Promise<void>((resolve, reject) => {
      const transaction = db.transaction([CONVERSATIONS_STORE], "readwrite");
      const store = transaction.objectStore(CONVERSATIONS_STORE);

      for (const conv of batch) {
        const enrichedConv: Omit<Conversation, "id"> = {
          ...conv,
          hasSparql: !!conv.sparql_block,
          hasInvalidQuery: hasInvalidQueryStep(conv.steps),
          messageCount: conv.messages.length,
          bgpCount: conv.sparql_block?.bgp_count ?? 0,
          searchText: buildSearchText(conv),
          hasMultipleResults: hasMultipleResults(conv.messages),
          hasZeroResults: hasZeroResults(conv.messages),
          hasErrors: hasErrors(conv.messages),
        };
        store.add(enrichedConv);
      }
      transaction.oncomplete = () => resolve();
      transaction.onerror = () => reject(new Error(`Failed to store conversations batch`));
    });
  }
};

/**
 * Delete all conversations for a specific label
 */
const deleteConversationsByLabel = async (label: string): Promise<void> => {
  const db = await initDB();

  return new Promise((resolve, reject) => {
    const transaction = db.transaction([CONVERSATIONS_STORE], "readwrite");
    const store = transaction.objectStore(CONVERSATIONS_STORE);
    const index = store.index("label");
    const request = index.openCursor(IDBKeyRange.only(label));

    request.onsuccess = event => {
      const cursor = (event.target as IDBRequest<IDBCursorWithValue>).result;
      if (cursor) {
        cursor.delete();
        cursor.continue();
      }
    };

    transaction.oncomplete = () => resolve();
    transaction.onerror = () => reject(new Error(`Failed to delete conversations for: ${label}`));
  });
};

/**
 * Get filtered and paginated conversations from IndexedDB
 */
export const getFilteredConversations = async (
  filters: ConversationFilters,
  page: number = 1,
  pageSize: number = 50
): Promise<PaginatedResult> => {
  const db = await initDB();
  const search = filters.searchQuery.toLowerCase().trim();

  return new Promise((resolve, reject) => {
    const transaction = db.transaction([CONVERSATIONS_STORE], "readonly");
    const store = transaction.objectStore(CONVERSATIONS_STORE);
    const index = store.index("label");

    const matching: Conversation[] = [];
    const request = index.openCursor(IDBKeyRange.only(filters.label));

    request.onsuccess = event => {
      const cursor = (event.target as IDBRequest<IDBCursorWithValue>).result;

      if (cursor) {
        const conv = cursor.value as Conversation;

        // Apply filters
        let matches = true;

        // SPARQL filter
        if (conv.hasSparql && !filters.withSparql) matches = false;
        if (!conv.hasSparql && !filters.withoutSparql) matches = false;

        // Invalid query filter
        if (!conv.hasInvalidQuery && filters.withInvalidQuery) matches = false;

        // Query result filters
        if (!conv.hasMultipleResults && filters.withMultipleResults) matches = false;
        if (!conv.hasZeroResults && filters.withZeroResults) matches = false;
        if (!conv.hasErrors && filters.withErrors) matches = false;

        // Min messages filter
        if (conv.messageCount < filters.minMessages) matches = false;

        // Min BGPs filter
        if (filters.minBgps > 0 && !conv.hasSparql) matches = false;
        if (filters.minBgps > 0 && conv.bgpCount < filters.minBgps) matches = false;

        // Search filter
        if (search && !conv.searchText.includes(search)) matches = false;

        if (matches) {
          matching.push(conv);
        }

        cursor.continue();
      } else {
        // Cursor exhausted - apply pagination
        const total = matching.length;
        const totalPages = Math.ceil(total / pageSize);
        const startIndex = (page - 1) * pageSize;
        const paginatedConversations = matching.slice(startIndex, startIndex + pageSize);

        resolve({
          conversations: paginatedConversations,
          total,
          page,
          pageSize,
          totalPages,
        });
      }
    };

    request.onerror = () => reject(new Error("Failed to query conversations"));
  });
};

/**
 * Get summary statistics for all conversations
 */
export const getSummary = async (): Promise<Summary> => {
  const db = await initDB();

  return new Promise((resolve, reject) => {
    const transaction = db.transaction([CONVERSATIONS_STORE], "readonly");
    const store = transaction.objectStore(CONVERSATIONS_STORE);
    const request = store.getAll();

    request.onsuccess = () => {
      const allConversations = request.result as Conversation[];
      const summary: Summary = {
        likes: 0,
        likes_sparql: 0,
        dislikes: 0,
        dislikes_sparql: 0,
        langfuse: 0,
        langfuse_sparql: 0,
        sparql_total: 0,
        conversation_total: allConversations.length,
      };
      for (const conv of allConversations) {
        if (conv.label === "likes") {
          summary.likes++;
          if (conv.hasSparql) summary.likes_sparql++;
        } else if (conv.label === "dislikes") {
          summary.dislikes++;
          if (conv.hasSparql) summary.dislikes_sparql++;
        } else if (conv.label === "langfuse") {
          summary.langfuse++;
          if (conv.hasSparql) summary.langfuse_sparql++;
        }
        if (conv.hasSparql) summary.sparql_total++;
      }
      resolve(summary);
    };

    request.onerror = () => reject(new Error("Failed to get summary"));
  });
};

/**
 * Get all file metadata (to know which files are uploaded)
 */
export const getAllFileMeta = async (): Promise<FileMeta[]> => {
  const db = await initDB();
  return new Promise((resolve, reject) => {
    const transaction = db.transaction([FILE_META_STORE], "readonly");
    const store = transaction.objectStore(FILE_META_STORE);
    const request = store.getAll();
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(new Error("Failed to get file metadata"));
  });
};

/**
 * Get file metadata for a specific file type
 */
export const getFileMeta = async (fileType: "likes" | "dislikes" | "langfuse"): Promise<FileMeta | null> => {
  const db = await initDB();
  return new Promise((resolve, reject) => {
    const transaction = db.transaction([FILE_META_STORE], "readonly");
    const store = transaction.objectStore(FILE_META_STORE);
    const request = store.get(fileType);
    request.onsuccess = () => resolve(request.result || null);
    request.onerror = () => reject(new Error(`Failed to get file meta: ${fileType}`));
  });
};

/**
 * Clear all stored data
 */
export const clearAllStoredConversations = async (): Promise<void> => {
  const db = await initDB();

  await new Promise<void>((resolve, reject) => {
    const transaction = db.transaction([CONVERSATIONS_STORE, FILE_META_STORE], "readwrite");
    transaction.objectStore(CONVERSATIONS_STORE).clear();
    transaction.objectStore(FILE_META_STORE).clear();
    transaction.oncomplete = () => resolve();
    transaction.onerror = () => reject(new Error("Failed to clear all data"));
  });

  dbInstance = null;
};

/**
 * Delete a specific file type's data
 */
export const deleteFileData = async (fileType: "likes" | "dislikes" | "langfuse"): Promise<void> => {
  const db = await initDB();

  // Delete file meta
  await new Promise<void>((resolve, reject) => {
    const transaction = db.transaction([FILE_META_STORE], "readwrite");
    const store = transaction.objectStore(FILE_META_STORE);
    const request = store.delete(fileType);
    request.onsuccess = () => resolve();
    request.onerror = () => reject(new Error(`Failed to delete file meta: ${fileType}`));
  });

  // Delete all conversations for this label
  await deleteConversationsByLabel(fileType);
};

/**
 * Create a mock File object from file metadata (for backward compatibility with UI)
 */
export const createFileFromMeta = (meta: FileMeta): File => {
  const blob = new Blob([""], {type: "application/json"});
  return new File([blob], meta.fileName, {
    type: "application/json",
    lastModified: meta.uploadedAt,
  });
};
